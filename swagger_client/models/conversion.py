# coding: utf-8

"""
    trustshare API

    Welcome to the trustshare API Reference documentation. Here you can find detailed information about the endpoints we provide as well as the shape of entities within the system.  # Environments The trustshare API has two environments, __Sandbox__ and __Live__. Both environments are available under the same endpoint however API Keys and client secrets are prefixed with the environment name. - A __Sandbox__ API Key will be in the format: `sandbox_api_[0-9a-z]`. - A __Live__ API Key will be in the format: `live_api_[0-9a-z]`.  ## Sandbox Our __Sandbox__ environment endeavours to be as close to the __Live__ environment as possible, however, there are a couple of limitations and features which should be noted. - Card payments take around 7 days to settle into accounts. In __Live__ this is generally closer to 2 days. - Manual inbound payments can only be \"faked\" in __Sandbox__ when they are less-than or equal-to `250,000.00`. - Open Banking in __Sandbox__ will always use a \"Mock Bank\" UI to accept the payment.  # noqa: E501

    OpenAPI spec version: 1.0.23
    Contact: support@trustshare.co
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class Conversion(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        '_from': 'Currency',
        'to': 'BankAccountCurrency',
        'status': 'ConversionStatus',
        'expected_amount': 'int',
        'rate': 'float'
    }

    attribute_map = {
        '_from': 'from',
        'to': 'to',
        'status': 'status',
        'expected_amount': 'expected_amount',
        'rate': 'rate'
    }

    def __init__(self, _from=None, to=None, status=None, expected_amount=None, rate=None):  # noqa: E501
        """Conversion - a model defined in Swagger"""  # noqa: E501
        self.__from = None
        self._to = None
        self._status = None
        self._expected_amount = None
        self._rate = None
        self.discriminator = None
        if _from is not None:
            self._from = _from
        if to is not None:
            self.to = to
        if status is not None:
            self.status = status
        if expected_amount is not None:
            self.expected_amount = expected_amount
        if rate is not None:
            self.rate = rate

    @property
    def _from(self):
        """Gets the _from of this Conversion.  # noqa: E501


        :return: The _from of this Conversion.  # noqa: E501
        :rtype: Currency
        """
        return self.__from

    @_from.setter
    def _from(self, _from):
        """Sets the _from of this Conversion.


        :param _from: The _from of this Conversion.  # noqa: E501
        :type: Currency
        """

        self.__from = _from

    @property
    def to(self):
        """Gets the to of this Conversion.  # noqa: E501


        :return: The to of this Conversion.  # noqa: E501
        :rtype: BankAccountCurrency
        """
        return self._to

    @to.setter
    def to(self, to):
        """Sets the to of this Conversion.


        :param to: The to of this Conversion.  # noqa: E501
        :type: BankAccountCurrency
        """

        self._to = to

    @property
    def status(self):
        """Gets the status of this Conversion.  # noqa: E501


        :return: The status of this Conversion.  # noqa: E501
        :rtype: ConversionStatus
        """
        return self._status

    @status.setter
    def status(self, status):
        """Sets the status of this Conversion.


        :param status: The status of this Conversion.  # noqa: E501
        :type: ConversionStatus
        """

        self._status = status

    @property
    def expected_amount(self):
        """Gets the expected_amount of this Conversion.  # noqa: E501

        The expected amount of the conversion in the target currency. The amount is always in the lowest denomination of the target currency, so please be aware of the target currencies _minor unit_.  # noqa: E501

        :return: The expected_amount of this Conversion.  # noqa: E501
        :rtype: int
        """
        return self._expected_amount

    @expected_amount.setter
    def expected_amount(self, expected_amount):
        """Sets the expected_amount of this Conversion.

        The expected amount of the conversion in the target currency. The amount is always in the lowest denomination of the target currency, so please be aware of the target currencies _minor unit_.  # noqa: E501

        :param expected_amount: The expected_amount of this Conversion.  # noqa: E501
        :type: int
        """

        self._expected_amount = expected_amount

    @property
    def rate(self):
        """Gets the rate of this Conversion.  # noqa: E501

        The conversion rate in the form `from` -> `to`.  # noqa: E501

        :return: The rate of this Conversion.  # noqa: E501
        :rtype: float
        """
        return self._rate

    @rate.setter
    def rate(self, rate):
        """Sets the rate of this Conversion.

        The conversion rate in the form `from` -> `to`.  # noqa: E501

        :param rate: The rate of this Conversion.  # noqa: E501
        :type: float
        """

        self._rate = rate

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(Conversion, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Conversion):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
